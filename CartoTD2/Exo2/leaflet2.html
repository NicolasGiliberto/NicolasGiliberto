<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaflet - Exercice 2</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map {
            height: 100vh; /* Hauteur de la carte */
            width: 100%; /* Largeur de la carte */
            position: absolute; /* Position absolue pour éviter les problèmes */
            top: 0; /* Positionne en haut */
            left: 0; /* Positionne à gauche */
        }
    </style>
</head>
<body>
    <h1>Géolocalisation et carte Leaflet - Exercice 2</h1>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        let map; // Déclare la variable de la carte

        // Fonction pour initialiser la carte
        function initMap(position) {
            const userLat = position.coords.latitude;
            const userLon = position.coords.longitude;
            const userAccuracy = position.coords.accuracy;

            // Vérifie si la carte existe déjà et la détruit si c'est le cas
            if (map) {
                map.remove(); // Retire l'ancienne carte
            }

            // Initialise la carte centrée sur la position GPS
            map = L.map('map').setView([userLat, userLon], 5);

            // Ajoute le calque Esri World Imagery
            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
            }).addTo(map);

            // Ajoute un marqueur à la position de l'utilisateur
            L.marker([userLat, userLon]).addTo(map)
                .bindPopup("Vous êtes ici")
                .openPopup();

            // Dessine un cercle autour de la position avec la précision
            L.circle([userLat, userLon], { 
                radius: userAccuracy,
                color: 'blue',
                fillOpacity: 0.3 
            }).addTo(map).bindPopup("Précision : " + userAccuracy + " mètres");

            // Coordonnées de Marseille et Nice
            const marseille = { lat: 43.2965, lon: 5.3698 };
            const nice = { lat: 43.7031, lon: 7.2661 };

            // Trace le triangle des Bermudes
            const triangleBermudes = [
                [25.0, -71.0],  // Pointe du triangle
                [18.0, -65.0],  // Autre point
                [32.0, -64.0]   // Dernier point
            ];
            L.polygon(triangleBermudes, { color: 'red' }).addTo(map);

            // Trace le segment entre Marseille et Nice
            L.polyline([[marseille.lat, marseille.lon], [nice.lat, nice.lon]], { color: 'green' }).addTo(map);
            
            // Calcule la distance entre Marseille et la position de l'utilisateur
            const distanceMarseille = calculateDistance(marseille.lat, marseille.lon, userLat, userLon);
            L.marker([marseille.lat, marseille.lon]).addTo(map)
                .bindPopup("Marseille")
                .openPopup();
            L.marker([nice.lat, nice.lon]).addTo(map)
                .bindPopup("Nice")
                .openPopup();
            
            // Affiche la distance dans un popup
            L.popup()
                .setLatLng([userLat, userLon])
                .setContent("Distance entre Marseille et votre position : " + distanceMarseille.toFixed(2) + " km")
                .openOn(map);
        }

        // Fonction pour calculer la distance entre deux points (Haversine)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Rayon de la Terre en km
            const dLat = toRadians(lat2 - lat1);
            const dLon = toRadians(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance en km
        }

        // Convertit les degrés en radians
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        // Fonction en cas d'échec de géolocalisation
        function errorHandler(err) {
            console.error(`Erreur lors de la géolocalisation: ${err.message}`);
        }

        // Demande la géolocalisation au navigateur
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(initMap, errorHandler);
        } else {
            alert("Votre navigateur ne supporte pas la géolocalisation.");
        }
    </script>
</body>
</html>
